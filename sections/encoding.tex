% !TEX root = ../main.tex
\subsection{Encoding in PDDL}\label{ssec:eip}

\newcommand{\myi}{\emph{(i)}\xspace}
\newcommand{\myii}{\emph{(ii)}\xspace}
\newcommand{\myiii}{\emph{(iii)}\xspace}
\newcommand{\myiv}{\emph{(iv)}\xspace}
\newcommand{\myv}{\emph{(v)}\xspace}
\newcommand{\myvi}{\emph{(vi)}\xspace}
\newcommand{\A}{\mathcal{A}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\PDDL}[1]{\begin{footnotesize}\texttt{#1}\end{footnotesize}}
%E.g., the alignment result $\hat{t_\sigma}=p_5\;\texttt{A}\;\texttt{A}\;\textit{ins\_}p_8$ of trace $\sigma=$\texttt{B\{x=1,y=0\}A\{x=6\}\\A\{x=4\}} generates the repair $\varrho=[@\sigma_4\leftarrow p_8]$ after removing the \texttt{sync} operations.

In this section, we show how, given an augmented constraint automaton $\mathcal{A}_{\varphi_{\mathcal{M}}}^+$ obtained from an LTL$_f$ formula  $\varphi_{\mathcal{M}}$, and an augmented trace automaton $\T^+$ obtained from a trace $t$, we build a cost-optimal planning domain $\mathcal{P_D}$ and a problem instance $\mathcal{P}$ in PDDL. $\mathcal{P_D}$ and $\mathcal{P}$ can be used to feed any state-of-the-art planners accepting PDDL 2.1 specifications, as discussed in Section \ref{ssec:ap}.
%
A solution plan for $\mathcal{P}$ amounts to the set of interventions of minimal cost to repair the trace with respect to $\varphi_{\mathcal{M}}'$,\added{ and generates a repair sequence $\varrho$ that is going to be exploited in the forthcoming subsection for finally repairing the trace.}

%\paragraph{Planning Domain}
\medskip
\noindent
\textbf{Planning Domain.}
%
In $\mathcal{P_D}$, we provide two abstract types: \PDDL{activity} and \PDDL{state}.
%
The first captures the activities involved in a transition between two different states of a constraint/trace automaton.
%
The second is used to uniquely identify the states of the constraint automaton (through the sub-type \texttt{automaton\_state}) and of the trace automaton (through the sub-type \texttt{trace\_state}).
%
To capture the structure of the automaton and to monitor its evolution, we defined five \emph{domain propositions} as boolean predicates in $\mathcal{P_D}$:
%
\begin{itemize}
	\item \PDDL{(trace ?t1 - trace\_state ?e - activity ?t2 - trace\_state)} holds if there exists a transition in the trace automaton between two states \texttt{t1} and \texttt{t2}, being \texttt{e} the activity involved in the transition.
	\item \PDDL{(automaton ?s1 - automaton\_state ?e - activity ?s2 - automaton\_state)} holds if there exists a transition between two states \texttt{s1} to \texttt{s2} of a constraint automaton, being \texttt{e} the activity involved in the transition.
    \item \PDDL{(atoms ?e1 - activity ?e2 - activity)} holds if \texttt{e1} and \texttt{e2} are two atoms in $\Sigma$ associated to a same activity label.
	\item \PDDL{(cur\_state ?s - state)} holds if \texttt{s} is the current state of a constraint/trace automaton.
	\item \PDDL{(final\_state ?s - state)} holds if \texttt{s} is a final state of a constraint/trace automaton.
\end{itemize}
It is worth to notice that, if a generic activity \texttt{A} is associated to some data condition, \texttt{A} will be represented as a set of atoms $p_1$, $p_2$, $p_3$, etc. in $\mathcal{P_D}$, see for example Table \ref{tab:dimGMM}. This means that, for any combination of atoms $p_i$ - $p_j$ associated to \texttt{A}, there will exist an instance of the predicate \PDDL{(atoms)} that will hold for $p_i$ and $p_j$.
%
%Label \texttt{C} is never associated to a data condition, and therefore it will be associated to one single atom \texttt{C}. On the other hand, label \texttt{B} is associated to several atoms obtained by partitioning the data space via the intervals
%
Furthermore, we define a \emph{numeric fluent} \PDDL{total-cost} to keep track of the cost of the violations. Notice that: \myi in PDDL, parameters are written with a question mark character `?' in front, and the dash character `-' is used to assign types to parameters; and \myii we remain consistent with the PDDL syntax, which allows the values of both predicates and fluents to change as a result of the execution of an action.
%


Planning actions are used to express the \emph{repairs} on the original trace $t$. %Each action is characterized by its \emph{preconditions} and \emph{effects}, stated in terms of the domain propositions.
In our encoding, we have defined four actions to perform \emph{synchronous moves} both in the trace/constraint automaton, or to add/remove/replace activities to/from/in the constraint and trace automata. In the following, we suppose that actions \PDDL{ins}, \PDDL{del} and \PDDL{repl} have cost equal to 1. However, their cost can be customized to define the severity of a violation or to force priorities among actions.
%
%\begin{tiny}
%	\begin{verbatim}	
%	(:action sync                                          (:action add                              (:action del
%	:parameters (?t1 - path_state                           :parameters (?e - activity)               :parameters (?t1 - path_state
 %                ?e - activity                              :effect (and (increase (total-cost) 1)                  ?e - activity
  %               ?t2 - path_state)                           (forall (?s1 ?s2 - automaton_state)                    ?t2 - path_state)
%	:precondition (and (cur_state ?t1) (path ?t1 ?e ?t2))       (when (and (cur_state ?s1)            :precondition (and (cur_state ?t1)
%	:effect(and (not (cur_state ?t1)) (cur_state ?t2)           (automaton ?s1 ?e ?s2))               :effect(and (increase (total-cost) 1)
%	 (forall (?s1 ?s2 - automaton_state)                        (path ?t1 ?e ?t2))                    (not (cur_state ?t1)) (cur_state ?t2)))
%	   (when (and (cur_state ?s1)                               (and (not (cur_state ?s1))
%	   (automaton ?s1 ?e ?s2))                                  (cur_state ?s2))))))
%	   (and (not (cur_state ?s1))
%	   (cur_state ?s2))))))
%	\end{verbatim}
%\end{tiny}

\begin{scriptsize}
\begin{verbatim}
(:action sync
 :parameters (?t1 - trace_state ?e - activity ?t2 - trace_state)
 :precondition (and (cur_state ?t1) (trace ?t1 ?e ?t2))
 :effect(and (not (cur_state ?t1)) (cur_state ?t2)
             (forall (?s1 ?s2 - automaton_state)
               (when (and (cur_state ?s1)
                          (automaton ?s1 ?e ?s2))
                     (and (not (cur_state ?s1))(cur_state ?s2))))))
                     
(:action ins                                     (:action del
 :parameters (?e - activity)                      :parameters (?t1 - trace_state
 :effect (and (increase (total-cost) 1)                        ?e - activity
          (forall (?s1 ?s2 - automaton_state)                  ?t2 - trace_state)
            (when (and (cur_state ?s1)            :precondition (and (cur_state ?t1)
                       (automaton ?s1 ?e ?s2))                     (trace ?t1 ?e ?t2))
                   (and (not (cur_state ?s1))     :effect(and (increase (total-cost) 1)
                        (cur_state ?s2))))))         (not (cur_state ?t1))(cur_state ?t2)))

(:action repl
 :parameters (?t1 - trace_state ?e1 - activity ?t2 - trace_state ?e2 - activity)
 :precondition (and (cur_state ?t1) (trace ?t1 ?e1 ?t2) (atoms ?e1 ?e2))
 :effect(and (increase (total-cost) 1) (not (cur_state ?t1)) (cur_state ?t2)
             (forall (?s1 ?s2 - automaton_state)
               (when (and (cur_state ?s1)
                          (automaton ?s1 ?e2 ?s2))
                     (and (not (cur_state ?s1))(cur_state ?s2))))))
\end{verbatim}
\end{scriptsize}
\smallskip

\noindent
We modeled \PDDL{sync} and \PDDL{del} in such a way that they can be applied only if there exists a transition from the current state \PDDL{t1} of the trace automaton to a subsequent state \PDDL{t2}, being \PDDL{e} the activity involved in the transition.
%%
Notice that, while \PDDL{del} \added{$[\#\texttt{t1}\leftarrow \texttt{e}]$} yields a \emph{single} move in the trace automaton, \PDDL{sync} yields, in addition, one move on the constraint automaton, to be performed synchronously. In particular, a synchronous move is performed in the constraint automaton if there exists a transition involving activity \PDDL{e} connecting \PDDL{s1} -- the current state of the automaton -- to a state \PDDL{s2}.
%
Then, \PDDL{ins} \added{$[@\texttt{t1}\leftarrow \texttt{e}]$} is performed only for transitions involving activity \PDDL{e} connecting two states of the constraint automaton, with the current state of the trace automaton that remains the same after the execution of the action.
%
Finally, \PDDL{repl} \added{$[\texttt{t1}[\texttt{e1}\mapsto \texttt{e2}]]$} can be seen as a synchronous combination of a \PDDL{del} and an \PDDL{ins}. It yields one move on the trace automaton and one on the constraint automaton, involving two atoms \PDDL{e1} and \PDDL{e2} associated to a same activity label, i.e., such that the predicate \PDDL{(atoms ?e1 ?e2)} holds.

\smallskip
\noindent
\textbf{Planning Problem.}
%\paragraph{Planning Problem}
%
In $\mathcal{P}$, we first define a finite set of constants required to properly ground all the domain propositions defined in $\mathcal{P_D}$. In our case, constants correspond to the state and activity instances involved in the trace/constraint automaton.
%
Secondly, we define the \emph{initial state} of $\mathcal{P}$ to capture the exact structure of the trace/constraint automaton. This includes the specification of all the existing transitions that connect two states of the automaton, and the definition of all the pairs of atoms belonging to a same activity label. The current state and the final states of the trace/constraint automaton are identified as well.
%
Thirdly, to encode the goal condition, we first pre-process the constraint automaton by: \myi adding a new dummy state with no outgoing transitions; \myii adding a new special action, executable only in the final states of the original automaton, which makes the automaton move to the dummy state; and \myiii including in the set of final states only the dummy state. Then, we define the goal condition as the conjunction of the final states of the trace automaton and of the constraint automaton. In this way, we avoid using disjunctions in goal formulas, which are not supported by all planners.
%
Finally, as our purpose is to minimize the total cost of the plan, $\mathcal{P}$ contains the following specification: \PDDL{(:metric minimize (total-cost))}. \added{As the goal requires that in both augmented automata an accepting state is reached, the actions will encode the strategies to successfully visit both automata via their transition functions, while assigning different alignment costs to each of the strategies. When the goal is reached, the resulting action sequence (where \texttt{sync}s are stripped) represent the repair sequence $\varrho$ that we are going to exploit in the next section.} 