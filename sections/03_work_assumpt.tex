\section{Modeling Data-Aware Declare Alignment}
In this section, we introduce the requirements enabling the computation of data-aware declare alignments.

\subsection{Data-Aware Logs}
(Data) \textit{payloads} are finite functions $p\in V^K$, where $K$ is a finite set of keys and $V$ is a (finite) set of data values. We denote $\bot$ as an element $\bot\notin V$, such that $p(k)=\bot$ for $k\notin\textup{dom}(p)$. An event $\sigma_j$ is a pair $\Braket{\texttt{a},p}$, where $\texttt{a}\in\textsf{Act}$ is a finite set of activity labels, and $p$ is a payload; we denote $\lambda$ (and $\varsigma$) as the first (and second) projection of such pair, i.e., $\lambda(\sigma_j)=\texttt{a}$ (and $\varsigma(\sigma_j)=p$). A \textit{trace} $\sigma$ is a temporally-ordered sequence of distinct and finite events $\sigma_1\cdots\sigma_n$., modeling a process run. We distinguish the trace keys ($K_t$) from the event keys ($K_e$), such that $K=K_t\cup K_e$ with $K_t\cap K_e=\emptyset$: all events within the same trace associate the same values to the same trace keys, i.e., $\forall \Braket{\texttt{a}_i,p_i},\Braket{\texttt{a}_j,p_j}\in\sigma.\;\forall k\in K_t.\; p_i(k)=p_j(k)$. A log $\mathcal{L}$ is a finite set of traces. This  characterization is compliant with the \textsc{eXtensible Event Stream} format, which is the \textit{de facto} standard for representing event logs within the Business Process Management community \cite{SchonigCMM16,LenoDM18}.


\subsection{Data-Aware Declare}\label{ssec:dad}
\textsc{Declare} is a constraint-based process modeling language, where a Declare model $\mathcal{M}$ is described as a set of constraints $\Set{c_1,\dots,c_m}$ that must me simultaneously satisfied throughout the process execution. Due to space limitations, we avoid providing a detailed description of Data-Aware Declare \cite{SchonigCMM16,LenoDM18}, henceforth simply referred as Declare, and we will only describe its general features.

 Such constraints express either positive (or negative) dependencies between two events having labels $\texttt{a},\texttt{b}\in\textsf{Act}$, or quantify the occurrence of events having a specific label $\texttt{a}'\in\textsf{Act}$. In the first case, one of the two clause labels is called \textit{activation}, and the other \textit{target}; while testing a trace $\sigma$ for conformance over such clause, the presence of the activation in $\sigma$ triggers the clause verification, requiring the execution of the target in the same trace. Activations and targets can be additionally decorated with  data predicates $\phi^d$ (\textit{conditions}): while activation conditions must be valid when the activation label occurs within the event exhibiting such label, target conditions impose value limitations on events containing such target label. Even if current literature  considers \textit{correlation} conditions between activations and targets \cite{SchonigCMM16}, we will not model such constraints as previously discussed in \S\ref{sec:mot}. Such constraints can be represented by either an intuitive graphical representation, which makes them easy to use and interpret for process analysts, or with a formal semantics \cite{LeoniMA12}.

\begin{figure}[!t]
	\centering
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/example_1_graph}
		\caption{$\bot\Release(\neg p_3\vee p_1\vee p_2) \wedge \top\mathcal{U}p_1$}
		\label{fig:g1}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/example_2_graph}
		\caption{$\bot\Release(\neg\texttt{A}\vee(\top\Until(p_2\vee p_3)))\wedge\top\Until p_3$}
		\label{fig:g2}
	\end{subfigure}
	\caption{Representation of LTL$_f$ formulae as constraint automaton from \cite{LeoniMA12,Westergaard11}.}
	\label{fig:g1g2}
\end{figure}

\subsection{Working Assumptions}\label{sec:wa}
In this section, we outline some working assumptions that can be inferred from the literature of reference. First, we assume that we only want to deal with log traces \cite{XuLZ17a}; this implies that \begin{enumerate*}[label=\emph{\alph*})] \item the semantics of the Declare models can be expressed in Linear Time Logic on Finite Traces (LTL$_f$) \cite{10.1007/978-3-642-40176-3_8}, as logs are finite sets of finite traces \cite{GiacomoV13}; \item differently from \cite{BurattinMS16,MaggiMB19}, we work under the closed world assumptions, as the only possible set of traces that might satisfy a Declare constraints might come from its associated constraint automaton and, possibly, from the set of log traces; \item differently from \cite{MultiPerspective}, we can avoid to model reading and writing operation, as the entirety of our analyses will be conducted \textit{post-mortem}; \item last, each event trace must be represented by one single proposition \cite{XuLZ17a}. \end{enumerate*} The latter consideration will require us to partition the possible data space into distinct propositions. Still, we can freely assume that the constraint automatons generated from the LTL$_f$ interpretation of such Declare constraints allow to represent any possible event label that is not represented within the Declare constraints, by either representing it as a transition $\Sigma\backslash S$, where $\Sigma$ is the set of all the possible strings and $S$ is a (possibly empty) finite set of traces that we want to ignore \cite{LeoniMA12,Westergaard11}, or by representing it as finite conjunction of negated predicates \cite{Lydia}, where each predicate is a proposition that can be deduced from a Declare Model represented in LTL$_f$. Figure~\ref{fig:g1g2} provides a intuitive representation of some LTL$_f$ formulae in the former representation.

We can freely assume that activation and target with data conditions can be expressed as a propositional formula $\psi(\sigma_i):=\phi_{\texttt{a}}(\sigma_i)\wedge \phi^d(\sigma_i)$ for each event $\sigma_i$ \cite{LenoDM18}, where $\phi_{\texttt{a}}(\sigma_i)$ denotes a predicate $\lambda(\sigma_i)=\texttt{a}$ over the activation (or target) label \texttt{a}, $\phi^d(\sigma_i)$ denotes the associated data condition over $\varsigma(\sigma_i)$. The latter is a
%Firstly, $\phi_{\texttt{a}}(\sigma_i)$ is always an atomic predicate $\lambda(\sigma_i)=\texttt{a}$ over the activation (or target) label $\texttt{a}\in\textsf{Act}$; such predicates are usually denoted simply as ``\texttt{a}'' \cite{XuLZ17a}. Secondly, $\phi^d(\sigma_i)$ is yet another
propositional formula containing either the universal truth ($\textbf{true}$), or the falsehood ($\textbf{false}$), or a predicate in the form ``$\varsigma(\sigma_i)(k)\;\Re\;c$'', usually denoted as ``$\texttt{a}.k\;\Re\;c$''; such predicate puts in relation $\Re$ the value associated to the key $k\in K$ within  payload $\varsigma(\sigma_i)$ to a constant value $c$, %where the data value $\varsigma(\sigma_i)(k)$ associated to the key $k$ within the payload $\varsigma(\sigma_i)$ o 
%
%
%, as well as their associated conditions, can be expressed in propositional logic over one single event $\sigma_i$. With respect to the activity label conditions for events $\sigma_i$, we can express those as a single atomic predicate in the form ``$\lambda(\sigma_i)=\texttt{a}$'' for each $\texttt{a}\in\textsf{Act}$; we will use ``\texttt{a}'' as a shorthand for such predicates. With respect to the (data) conditions, we assume that each atomic predicate refers to 
%
%We assume that the conditions for Declare clauses are always expressed in propositional calculus, where the atomic predicates are always in the form ``$\texttt{A}.\textit{var}\;\Re\; c$'', where \texttt{A} is a trace label containing a property named \textit{var} which is put in a binary relation $\Re$ with a constant value $c$, 
representing either a number or a string. $\Re$ could be either an equality or a precedence/subsequent relation or their negation. This is a widely adopted assumption, that spans from data-aware procedural models \cite{MultiPerspective} to data-aware declarative models \cite{10.1007/978-3-642-40176-3_8}. Furthermore, this assumption can be also adapted to categorical data, as strings are ordered via lexicographical orderings over the single characters \cite{MultiPerspective}.

Last, we freely assume that all the events having the same label will always contain the same set of keys, with possibly differently associated values. This is a common assumption in relational database field, where all the rows belonging to the same table contain the same number of values. We also freely assume that missing values are represented with specific values, such as an empty string, $-1$, $0$, $-\infty$, or $+\infty$, depending on the context.