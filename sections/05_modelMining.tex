\subsection{Data-Driven Declare Model Mining}\label{ref:dddmm}
In some other use cases, the model $\DeclModel$ is unknown, and we want to mine the set of plausible rules from a log \cite{MaggiMA11}. In this case, we are interested in knowing which and how many log traces $\sigma_L$ satisfy (albeit approximately) a Declare constraint $P$. This requires to visit the same log dataset multiple times for multiple candidate constraints $P\in\DeclConstr$: although it already exists a previous attempt at minining declarative models via relational databases \cite{SSRSA}, state-of-the-art interpretation of relational queries face inefficient implementation of aggregation operations \cite{BergamiPM18}. It can be showed that some counting constraints (e.g., \texttt{existence}, \texttt{init}) can be efficiently computed while loading the data traces within the relational database thus avoiding the counting cost: however, the authors did not consider this possibility in their implementation. Furthermore, row-oriented systems such as the Microsoft SQL Server exploited in \cite{SSRSA} are not particularly query efficient if compared to column-based storage \cite{IdreosGNMMK12}, where each $n$-ary relation $r(\texttt{id},A_1,\dots,A_n)$ can be decomposed into $n$ relations $r_i(\texttt{id},A_i)$. Last, at the time of the writing, no relational database system is capable of running multiple queries contemporaneously while minimising the data access and visit time to the log space: in this paper, we provide a from-scratch implementation of a in-memory relational database for data-driven declare mining enabling an efficient parallel implementation of the query plan, thus making the mining of Data-Driven Declare Models particularly efficient.

$\sigma_1=\mathsf{aaab}\qquad\sigma_2=\mathsf{bbbba}\qquad\sigma_3=\mathsf{cbcbc}$
\medskip

\begin{figure}\centering
	\begin{tabular}{c|c|c}
	\toprule
	\multicolumn{3}{c}{\texttt{CountTemplate}}\\
	\toprule
	\texttt{act} & $\sigma_{\texttt{id}}$ & \texttt{count}\\
	\midrule
	$\mathsf{a}$& 1 & 3 \\
	$\mathsf{a}$& 2 & 1 \\
	$\mathsf{a}$& 3 & 0 \\
	$\mathsf{b}$& 1 & 1 \\
	$\mathsf{b}$& 2 & 4 \\
	$\mathsf{b}$& 3 & 2 \\
	$\mathsf{c}$& 1 & 0 \\
	$\mathsf{c}$& 2 & 0 \\
	$\mathsf{c}$& 3 & 3 \\
	\bottomrule
\end{tabular} \begin{tabular}{c|c|c|c|c}
\toprule
\multicolumn{5}{c}{\texttt{Act}}\\
\toprule
 \texttt{act} & $\sigma_{\texttt{id}}$ & \texttt{time} & \texttt{next} & \texttt{prev}\\
\midrule
 $\mathsf{a}$ &1 & 0.00 &  2 & $-\infty$\\ 	%1	1
 $\mathsf{a}$ &1 & 0.33 &  3 & 1\\ 			%2	2
 $\mathsf{a}$ &1 & 0.66 &  \textbf{5} & 2\\ 			%3	3
 $\mathsf{a}$ &2 & 1.00 &  $+\infty$ & \textbf{9}\\ 	%9	4
 $\mathsf{b}$ &1 & 1.00 &  $+\infty$ & 3\\	%4	5
 $\mathsf{b}$ &2 & 0.00 &  \textbf{7} & $-\infty$\\ 	%5	6
 $\mathsf{b}$ &2 & 0.25 &  \textbf{8} & \textbf{6}\\ 			%6	7
 $\mathsf{b}$ &2 & 0.50 &  \textbf{9} & \textbf{7}\\ 			%7	8
 $\mathsf{b}$ &2 & 0.75 &  \textbf{4} & \textbf{8}\\ 			%8	9
 $\mathsf{b}$ &3 & 0.25 &  \textbf{13} & \textbf{12}\\ 		%11	10
 $\mathsf{b}$ &3 & 0.75 &  14 & \textbf{13}\\ 		%13	11
 $\mathsf{c}$ &3 & 0.00 &  \textbf{10} & $-\infty$\\ %10	12
 $\mathsf{c}$ &3 & 0.50 &  \textbf{11} & \textbf{10}\\ 		%12	13
 $\mathsf{c}$ &3 & 1.00 &  $+\infty$ & \textbf{11}\\ %14	14
\bottomrule
\end{tabular} \begin{tabular}{c|c|c}
\toprule
\multicolumn{3}{c}{\texttt{AttributeK}$_i$\quad($\mathbf{P}$)}\\
\toprule
 \texttt{act} & \texttt{value} & \texttt{ActOffset}\\
 \midrule
 $\cdots$ & $\cdots$ & $\cdots$\\

\bottomrule
\end{tabular}\end{figure}

In the following expressions, the alignment returns a pair, where the first element is the candidate trace for a model, and the second argument is the alignment similarity.
\begin{itemize}

\item $\mathcal{A}(\mathsf{init}(A),\mathcal{L})=\pi_{\sigma_{\texttt{id}},\tilde{{t}}}(\textit{Calc}_{{\tilde{{t}}}:=1-\texttt{time}}(\sigma_{\texttt{act}=A}(\texttt{Act}))$
\item $\mathcal{A}(\mathsf{end}(A),\mathcal{L})=\pi_{\sigma_{\texttt{id}},\texttt{time}}(\sigma_{\texttt{act}=A}(\texttt{Act})))$
\item $\mathcal{A}(\mathsf{exactly}(A,n),\mathcal{L})=\pi_{\sigma_{\texttt{id}},\tilde{t}}(\textit{Calc}_{\tilde{t}:=1-\frac{|n-\texttt{count}|}{\mathsf{len}(\sigma_\texttt{id})}}(\sigma_{\texttt{act}=A}(\texttt{CountTemplate})))$
\item $\mathcal{A}(\mathsf{existence}(A,n),\mathcal{L})=\pi_{\sigma_{\texttt{id}},\tilde{t}}(\textit{Calc}_{\tilde{t}:=|\texttt{count}\geq n|\texttt{?}\;1\;\texttt{:}1-\frac{|n-\texttt{count}|}{\mathsf{len}(\sigma_\texttt{id})}}(\sigma_{\texttt{act}=A}(\texttt{CountTemplate})))$
\item \begin{align*}
\mathcal{A}(\mathsf{respexistence}(&A,B,\mathbf{P}),\mathcal{L})\\
&=\mathsf{notexists}^1(A)\oplus\mathsf{ifte}_{\sigma\mapsto(A\wedge \mathbf{P})(\sigma)}(\mathsf{exists}^1(B){\color{red}\oplus\mathsf{notexists}^{c}(B)},\;\top^1)
\end{align*}
\end{itemize} {\color{red}with $c\in[0,1]\subseteq\mathbb{R}_{\geq 0}$}


\begin{align*}
\mathsf{respexistence}(A,B,\mathbf{P})&=\Diamond(A\wedge \mathbf{P})\Rightarrow\Diamond B\\
	&=\sigma\mapsto [\exists t. \lambda(\sigma_t)=A\wedge \mathbf{P}(\sigma_t)]\Rightarrow [\exists t. \lambda(\sigma_t)=B]\\
	&=\sigma\mapsto\texttt{if}\;{|\Set{t\leq |\sigma|\;|\;\lambda(\sigma_t)=A}|=0}\;\texttt{then}\\
	&\qquad\qquad \texttt{return}\;1\\
	&\qquad\quad\;\; \texttt{else if}\; \lambda(\sigma_t)=A\wedge\mathbf{P}(\sigma_t)\;\texttt{then}\\
	&\qquad\qquad \texttt{return\;\{\;if}\;(\exists t.\lambda(\sigma_t)=B)\;   \texttt{then}\;1\;\texttt{else}\;{\color{red}c}\texttt{\}}\\
	&\qquad\quad\;\; \texttt{else return}\;1\\
\end{align*}
\[\mathsf{exists}^i(A)=\Set{\braket{i,l}|l\in\pi_{\sigma_{\texttt{id}}}(\sigma_{\texttt{act}=A\wedge \texttt{count}\neq0}(\texttt{CountTemplate}))}\]
\[\mathbf{P}=\bigwedge_{\texttt{K}_i\theta} \mathbf{P}_{\texttt{K}_i\theta}=\bigcap \sigma_{\mathbf{P}_{\texttt{K}_i\theta}}(\texttt{AttributeK}_i)\]
\[\mathsf{notexists}^i(A)=\Set{\braket{i,l}|l\in\pi_{\sigma_{\texttt{id}}}(\sigma_{\texttt{act}=A\wedge \texttt{count}=0}(\texttt{CountTemplate}))}\]

$\oplus$ is the disjoint union, i.e., it assumes that the left and the right operands have no elements in common, so that the weighted union of two sets $A\oplus B$ is defined as follows:
\[A\oplus B=\Set{\braket{a,p}|\braket{a,p}\in A\veebar \braket{a,p}\in B}\]
The intersection of two weighted set is the following:
\[A\cap B=\Set{\braket{a,pq}|\braket{a,p}\in A \wedge \braket{a,q}\in B}\]
Still, this definition of intersection excludes the elements satisfying either $A$ or $B$, thus only including traces satisfying both constraints. In order to overcome to this limitation, we can provide the following definition of n-ary set intersection:
\[\bigcap_n S_n = \Set{\Braket{a,\frac{1}{n}\sum_{\braket{a,p_i}\in S_i}^{i\leq n}p_i}|\exists j\leq n. \braket{a,\_}\in S_j}\]




